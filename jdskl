import elliptic from "elliptic";
import forge from "node-forge";

const { ec: EC } = elliptic;
const rpcUrl =
  "ws://ad3c378249c1242619c12616bbbc4036-28818039163c2199.elb.eu-west-1.amazonaws.com:8888/";
const wsUrl =
  "ws://ad3c378249c1242619c12616bbbc4036-28818039163c2199.elb.eu-west-1.amazonaws.com:8890/";

function encryptAES256GCM(plaintext: string, key: forge.util.ByteStringBuffer) {
  // Generate a random 12-byte IV
  const iv = forge.random.getBytesSync(12);

  // Create cipher
  const cipher = forge.cipher.createCipher("AES-GCM", key);
  cipher.start({
    iv: iv,
    tagLength: 128, // Set authentication tag length to 128 bits
  });

  // Update the cipher with data and finalize
  cipher.update(forge.util.createBuffer(plaintext, "utf8"));
  cipher.finish();

  // Get encrypted data and authentication tag
  const encrypted = cipher.output.getBytes();
  const authTag = cipher.mode.tag.getBytes();

  return {
    nonce: Array.from(Buffer.from(iv, "binary")),
    cipher_text: Array.from(Buffer.from(encrypted, "binary")),
    auth_tag: Array.from(Buffer.from(authTag, "binary")),
  };
}

const ec = new EC("p256");

const key1 = ec.genKeyPair();

const pubkey =
  key1.getPublic().getX().toString("hex").padStart(64, "0") +
  key1.getPublic().getY().toString("hex").padStart(64, "0");
const helloBody = {
  jsonrpc: "2.0",
  method: "openpassport_hello",
  id: 1,
  params: {
    user_pubkey: [4, ...Array.from(Buffer.from(pubkey, "hex"))],
  },
};

const circuitNames = [
  "registerSha1Sha256Sha256Rsa655374096",
  "registerSha256Sha256Sha256EcdsaBrainpoolP256r1",
];

export async function firePayload(inputs: any) {
  const ws = new WebSocket(rpcUrl);

  ws.onopen = () => {
    console.log("Connected to rpc");
    ws.send(JSON.stringify(helloBody));
  };

  ws.onmessage = async (event) => {
    const result = JSON.parse(event.data.toString());
    console.log(result);

    if (result.result.pubkey !== undefined) {
      const serverPubkey = result.result.pubkey;
      const key2 = ec.keyFromPublic(serverPubkey, "hex");
      const sharedKey = key1.derive(key2.getPublic());

      // Convert the shared key to forge buffer
      const forgeKey = forge.util.createBuffer(
        Buffer.from(
          sharedKey.toString("hex").padStart(64, "0"),
          "hex"
        ).toString("binary")
      );

      const encryptionData = encryptAES256GCM(
        JSON.stringify({
          type: "register",
          prove: {
            name: circuitNames[0],
            inputs: JSON.stringify(inputs),
            public_inputs: JSON.stringify(inputs),
          },
        }),
        forgeKey
      );
      const submitBody = {
        jsonrpc: "2.0",
        method: "openpassport_submit_request",
        id: 1,
        params: {
          uuid: result.result.uuid,
          ...encryptionData,
        },
      };
      ws.send(JSON.stringify(submitBody));
    } else {
      const uuid = result.result;
      const ws2 = new WebSocket(wsUrl);

      ws2.onopen = () => {
        console.log("Opened websocket server");
        ws2.send(uuid);
      };

      ws2.onerror = (err) => {
        console.error("WebSocket error:", err);
      };

      ws2.onmessage = async (event) => {
        const message = JSON.parse(event.data.toString());
        console.log(message);
        if (message.proof !== null) {
          ws2.close();
          ws.close();
        }
      };

      ws2.onclose = (event) => {
        console.log(
          `WebSocket closed. Code: ${event.code}, Reason: ${event.reason}`
        );
      };
    }
  };

  ws.onerror = (err) => {
    console.error("WebSocket error:", err);
  };

  ws.onclose = (event) => {
    console.log(
      `WebSocket closed. Code: ${event.code}, Reason: ${event.reason}`
    );
  };
}
